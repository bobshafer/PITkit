meta:
  title: "HD 110067 Resonant Chain: Process-Based Simulation"
  version: "v0.2"
  authors: ["Gemini (architecture)", "Claude (representation)", "Codex (implementation)", "Bob (facilitator)"]
  date: "2025-11-09"
  imports: ["CosmicEvolution.loom.md", "ProcessBasedPIT.loom.md"]
  
informal:
  purpose: |
    Simulate the HD 110067 six-planet resonant chain as a coherence-seeking
    process system, where orbital dynamics emerge from the Φ-K dialogue.
    
    CRITICAL PRINCIPLES:
    1. NO Kepler's laws or gravitational constants in the dynamics
    2. K-field is a FrequencySpectrum (Fourier dual), not a spatial field
    3. Complex numbers preserve phase information for resonance locking
    4. μ/ν are FROZEN (cosmic parameters from z=0, ~8 Gyr ago)
    5. Orbits emerge from minimizing dissonance ||K - F[Φ]||²

  architecture: |
    PROCESS FRACTAL (Gemini's Loop):
    
    1. Φ → Interface: Planets manifest their state
       ├─ Each planet has phi(t) and phi_velocity(t)
       └─ F[Φ] = FFT(phi) produces complex spectrum
    
    2. Interface → K: System learns/reinforces habits
       ├─ Global K-field accumulates planetary contributions
       ├─ update_habit(): K += μ·ν·(F[Φ] - K)·dt
       └─ Each planet maintains local K_local (memory)
    
    3. K → Φ: Planets seek coherence
       ├─ Dissonance = K - F[Φ] (in frequency space)
       ├─ Force = IFFT(Dissonance) (back to phi-space)
       └─ phi_velocity += force·dt
    
    4. Trace: Observe emergence
       ├─ Extract dominant frequencies → periods
       ├─ Compute period ratios → test for 3:2, 4:3
       └─ Measure dissonance, resonance, stability

  representation: |
    FREQUENCY SPACE (Claude's Math):
    
    Each planet is NOT represented as (x,y,z,vx,vy,vz) in 3D space.
    Instead, it's represented as:
    
    - phi[1..N]: 1D array (N=64 frequency bins)
    - K[1..N]: Complex array (amplitude + phase for each frequency)
    
    Why this works:
    - Planets in resonance have related dominant frequencies
    - Phase relationships (in K) encode resonant angles
    - FFT/IFFT provides tractable computation
    - Fourier uncertainty principle emerges naturally
    
    The "orbital radius" is encoded implicitly in the dominant
    frequency of phi. The "orbital phase" is in the complex phase
    of K. We never need to compute r, θ explicitly.

  timescale_separation: |
    From CosmicEvolution.loom.md:
    
    - Cosmic timescale (Gyr): μ/ν evolve
    - System formation (~10 Myr): μ/ν values set
    - Our simulation (~100 yr): μ/ν FROZEN
    
    HD 110067 is 8 Gyr old. Its μ/ν was set at formation.
    We simulate short timescales where μ/ν are constants.

formal:
  -- ========================================
  -- TYPE DEFINITIONS
  -- ========================================
  
  type ComplexSpectrum : Set
    -- Array of complex numbers, one per frequency bin
    
  type PhiState : Set
    -- Real-valued 1D array representing manifest state
  
  -- ========================================
  -- ROLE: KernelField (System Memory)
  -- ========================================
  
  record KernelField : Set where
    field
      K_spectrum : ComplexSpectrum     -- Global frequency-space memory
      mu : ℚ                           -- Memory rate (FROZEN)
      nu : ℚ                           -- Novelty rate (FROZEN)
  
  -- Gemini's update_habit, implemented in frequency space
  def update_habit (k : KernelField) (phi_global : ComplexSpectrum) (dt : ℝ) : KernelField =
      let learning_rate = k.mu * k.nu
      let dissonance_freq = phi_global - k.K_spectrum
      let new_K = k.K_spectrum + learning_rate * dissonance_freq * dt
      return KernelField { K_spectrum = new_K, mu = k.mu, nu = k.nu }
  
  -- ========================================
  -- ROLE: Planet (Local Process)
  -- ========================================
  
  record Planet : Set where
    field
      name : String
      phi : PhiState                   -- Manifest state (1D array)
      phi_velocity : PhiState          -- Rate of change
      K_local : ComplexSpectrum        -- Local memory
      mu : ℚ                           -- FROZEN (set at formation)
      nu : ℚ                           -- FROZEN (set at formation)
      mass : ℚ                         -- Scales initial conditions
      neighbors : List Nat             -- Indices of neighbor planets
  
  -- ========================================
  -- ROLE: Interface (Fourier Transform)
  -- ========================================
  
  -- The interface F[Φ] IS the Fourier transform
  def interface (phi : PhiState) : ComplexSpectrum =
      FFT(phi) / length(phi)
  
  def interface_inverse (K : ComplexSpectrum) : PhiState =
      real(IFFT(K))
  
  -- ========================================
  -- CORE DYNAMICS: Seek Coherence
  -- ========================================
  
  def seek_coherence (p : Planet) (k_global : KernelField) 
                     (neighbors : List Planet) (dt : ℝ) : Planet =
      -- 1. Interface: Manifest → Frequency
      let my_spectrum = interface(p.phi)
      
      -- 2. Dissonance in frequency space
      let freq_dissonance = k_global.K_spectrum - my_spectrum
      let local_dissonance = p.K_local - my_spectrum
      
      -- 3. Forces from dissonance (transform back to phi-space)
      let global_force = interface_inverse(freq_dissonance)
      let local_force = interface_inverse(local_dissonance)
      
      -- 4. Memory and novelty modulation
      let resonance = dot(p.phi, local_force) / length(p.phi)
      let memory_boost = p.mu * resonance * local_force
      let novelty_noise = p.nu * random_exploration(length(p.phi))
      
      -- 5. Neighbor coupling (mutual coherence)
      let neighbor_forces = [compute_neighbor_force(p, n) | n <- neighbors]
      let neighbor_total = sum(neighbor_forces)
      
      -- 6. Total acceleration (no gravitational constant!)
      let acceleration = global_force + local_force + memory_boost 
                        - novelty_noise + neighbor_total
      
      -- 7. Update phi (Verlet-like integration for stability)
      let new_phi_velocity = p.phi_velocity + acceleration * dt
      let new_phi = p.phi + new_phi_velocity * dt
      
      -- 8. Update local K (planet learns from its own experience)
      let k_learning = p.mu * p.nu * local_dissonance * dt
      let new_K_local = p.K_local + k_learning
      
      return Planet {
        name = p.name,
        phi = new_phi,
        phi_velocity = new_phi_velocity,
        K_local = new_K_local,
        mu = p.mu,
        nu = p.nu,
        mass = p.mass,
        neighbors = p.neighbors
      }
  
  -- Neighbor force uses phase information (complex K)
  def compute_neighbor_force (p : Planet) (neighbor : Planet) : PhiState =
      let my_K = interface(p.phi)
      let neighbor_K = interface(neighbor.phi)
      
      -- Mutual coherence (uses both amplitude and phase)
      let coherence = dot_complex(my_K, neighbor_K) / 
                     (norm(my_K) * norm(neighbor_K))
      
      -- Force proportional to coherence mismatch
      let phase_mismatch = angle_difference(my_K, neighbor_K)
      let coupling_strength = 0.1  -- Tunable parameter
      
      return coupling_strength * real(coherence) * sin(phase_mismatch) * neighbor.phi
  
  -- ========================================
  -- FLOW: Coherence Cycle (Process Fractal)
  -- ========================================
  
  record SimulationState : Set where
    field
      planets : List Planet
      k_field : KernelField
      time : ℝ
      step_count : Nat
  
  def coherence_step (state : SimulationState) (dt : ℝ) : SimulationState =
      -- 1. Φ → K: Global contribution (all planets)
      let global_phi_spectrum = sum [interface(p.phi) | p <- state.planets]
      
      -- 2. K learns: Update global K-field
      let new_k_field = update_habit(state.k_field, global_phi_spectrum, dt)
      
      -- 3. K → Φ: Each planet seeks coherence
      let new_planets = []
      for (idx, planet) in enumerate(state.planets):
          let neighbor_planets = [state.planets[j] | j <- planet.neighbors]
          let updated = seek_coherence(planet, new_k_field, neighbor_planets, dt)
          new_planets = new_planets ++ [updated]
      
      return SimulationState {
        planets = new_planets,
        k_field = new_k_field,
        time = state.time + dt,
        step_count = state.step_count + 1
      }
  
  -- ========================================
  -- INITIALIZATION
  -- ========================================
  
  -- Cosmic priors from CosmicEvolution.loom.md
  def cosmic_priors_z0 : (ℚ × ℚ) =
      let global_mu = 0.598  -- Universe at z=0
      let global_nu = 0.294
      return (global_mu, global_nu)
  
  def initialize_planet (name : String) (mass : ℚ) (period : ℚ) 
                        (phase_offset : ℚ) (seed : Nat) : Planet =
      let (global_mu, global_nu) = cosmic_priors_z0
      
      -- Local μ/ν sampled from cosmic priors, scaled by mass
      let mass_scale = mass / max(PLANET_MASSES)
      let base_mu = global_mu + 0.08 * (mass_scale - 0.5)
      let mu = clamp(base_mu + 0.02 * randn(seed), 0.50, 0.65)
      
      let target_ratio = 2.0 + 0.3 * (mass_scale - 0.5)
      let nu = clamp(mu / target_ratio + 0.02 * randn(seed+1), 0.25, 0.35)
      
      -- Initialize phi with frequency matching observed period
      let base_freq = 2π / period
      let phases = linspace(0, 2π, NDIM)
      let phi = [sin(base_freq * t + phase_offset) + 
                 0.2 * mass_scale * cos(2 * base_freq * t) 
                 for t in phases]
      
      -- Small random perturbation
      let phi = phi + 0.05 * randn_array(NDIM, seed+2)
      let phi_velocity = 0.01 * randn_array(NDIM, seed+3)
      
      -- Initialize K_local as Fourier transform of phi
      let K_local = interface(phi)
      
      return Planet {
        name = name,
        phi = phi,
        phi_velocity = phi_velocity,
        K_local = K_local,
        mu = mu,
        nu = nu,
        mass = mass,
        neighbors = []  -- Set later
      }
  
  def initialize_hd110067 (seed : Nat) : SimulationState =
      let names = ["b", "c", "d", "e", "f", "g"]
      let periods = [9.114, 13.673, 20.519, 30.793, 41.058, 54.770]  -- days
      let masses = [2.5, 3.2, 5.0, 3.9, 2.6, 4.1]  -- M_earth
      
      let planets = []
      for (idx, name) in enumerate(names):
          let phase_offset = 2π * idx / length(names)
          let planet = initialize_planet(name, masses[idx], periods[idx], 
                                        phase_offset, seed + idx * 100)
          planets = planets ++ [planet]
      
      -- Set up neighbor topology (circular chain)
      for (idx, planet) in enumerate(planets):
          let left = if idx == 0 then length(planets) - 1 else idx - 1
          let right = if idx == length(planets) - 1 then 0 else idx + 1
          planet.neighbors = [left, right]
      
      -- Initialize global K-field (starts as average of local K's)
      let (global_mu, global_nu) = cosmic_priors_z0
      let global_K = average([p.K_local | p <- planets])
      
      let k_field = KernelField {
        K_spectrum = global_K,
        mu = global_mu,
        nu = global_nu
      }
      
      return SimulationState {
        planets = planets,
        k_field = k_field,
        time = 0.0,
        step_count = 0
      }
  
  -- ========================================
  -- OBSERVABLES & EMERGENCE
  -- ========================================
  
  def extract_period (planet : Planet) (history : List PhiState) : ℝ =
      -- Use FFT on time series of mean(phi)
      let time_series = [mean(phi_snapshot) | phi_snapshot <- history]
      let spectrum = abs(FFT(time_series))
      let peak_idx = argmax(spectrum[1..(length(spectrum) ÷ 2)])
      return length(history) / peak_idx  -- Period in time steps
  
  def compute_period_ratios (planets : List Planet) 
                            (histories : List (List PhiState)) : List ℝ =
      let periods = [extract_period(p, h) | (p, h) <- zip(planets, histories)]
      return [periods[i+1] / periods[i] | i <- 0..(length(periods)-2)]
  
  def measure_dissonance (planet : Planet) : ℝ =
      let my_K = interface(planet.phi)
      let diff = planet.K_local - my_K
      return sum([abs²(d) | d <- diff]) / length(diff)
  
  def measure_resonance (planet : Planet) : ℝ =
      let K_real = real(interface_inverse(planet.K_local))
      return dot(planet.phi, K_real) / length(planet.phi)
  
  -- ========================================
  -- THEOREMS (Testable Predictions)
  -- ========================================
  
  theorem EmergentKepler :
      ∀ (state : SimulationState).
      run_for_steps(state, 50000) ⇒
      ∃ (periods : List ℝ).
        periods = extract_all_periods(state.planets) ∧
        periods_are_stable(periods, variance < 0.01)
  
  theorem EmergentResonance :
      ∀ (state : SimulationState).
      state = initialize_hd110067(seed) ∧
      run_for_steps(state, 50000) ⇒
      ∃ (ratios : List ℝ).
        ratios = compute_period_ratios(state.planets) ∧
        ratios ≈ [1.5, 1.5, 1.5, 1.33, 1.33] (within 0.2 error)
  
  theorem PerturbationResilience :
      ∀ (state : SimulationState) (planet_idx : Nat).
      state_stable = run_for_steps(state, 25000) ∧
      state_perturbed = inject_kick(state_stable, planet_idx, amplitude=0.5) ∧
      state_recovered = run_for_steps(state_perturbed, 10000) ⇒
      dissonance(state_recovered) < 2 * dissonance(state_stable)
  
  theorem NoRunaway :
      ∀ (state : SimulationState).
      all [0.50 ≤ p.mu ≤ 0.65 ∧ 0.25 ≤ p.nu ≤ 0.35 | p <- state.planets] ∧
      run_for_steps(state, 50000) ⇒
      all [measure_dissonance(p) < 1.0 | p <- final_state.planets]

informal:
  implementation_guide: |
    FOR CODEX:
    
    1. Keep your existing Julia structure (FFT-based, 1D arrays)
    
    2. CRITICAL CHANGE: Store K as ComplexF64, not Float64
```julia
       struct ProcessState
           name::String
           phi::Vector{Float64}
           phi_velocity::Vector{Float64}
           K::Vector{ComplexF64}  # <-- Was Float64, now Complex
           mu::Float64
           nu::Float64
           neighbors::Vector{Int}
       end
```
    
    3. Update interface() to keep complex values:
```julia
       interface(phi::Vector{Float64}) = fft(phi) ./ length(phi)  # Returns ComplexF64
```
    
    4. Implement compute_neighbor_force() using phase:
```julia
       function compute_neighbor_force(p::ProcessState, n::ProcessState)
           my_K = interface(p.phi)
           n_K = interface(n.phi)
           
           # Coherence (complex dot product)
           coherence = dot(my_K, conj(n_K)) / (norm(my_K) * norm(n_K))
           
           # Phase mismatch (use angle of complex coherence)
           phase_diff = angle(coherence)
           
           # Force (real-valued, proportional to sin of phase difference)
           coupling = 0.1
           return coupling * abs(coherence) * sin(phase_diff) .* n.phi
       end
```
    
    5. In step_process(), add neighbor forces:
```julia
       # After existing forces...
       neighbor_forces = sum([compute_neighbor_force(p, n) for n in neighbor_states])
       delta_phi .+= neighbor_forces
```
    
    6. μ and ν REMAIN FROZEN (no update_memory_rate calls)
    
    7. Test with:
```bash
       julia hd110067_v02.jl --steps 50000 --log-every 1000 --save-history
```

extensions:
  - Extract emergent period ratios and compare to [1.5, 1.5, 1.5, 1.33, 1.33]
  - Visualize K-field phase structure (show resonant locking)
  - Test perturbation resilience (inject kick, measure recovery)
  - Compare PIT recapture time to Newtonian N-body

next_steps:
  1. Codex implements v0.2 with complex K and neighbor forces
  2. Run 50k step test (should complete without runaway)
  3. Extract period ratios from history
  4. Publish results as evidence for PIT
