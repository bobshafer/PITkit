# Loom × PIT — HD 110067 Resonant Chain Simulator

This project implements a falsifiable PIT model for the HD 110067 six-planet resonant chain. It couples a standard N-body integrator with a **PIT interaction layer** that adds a **state-dependent, resonance-gated coupling (“information spring”)** between adjacent planet pairs. The coupling strength evolves via a scalar **coherence mode** (C ∈ [0,1]) governed by memory/novelty dynamics.

## Goals

1. **Reproduce** near-commensurate period ratios and small resonant-angle librations reported for HD 110067.
2. **Test falsifiability**: turn PIT coupling off (ξ=0) and verify resonance fails to recapture after stochastic kicks.
3. **Estimate a Goldilocks zone** in parameter space ((\mu,\nu,\xi,\alpha,\beta,\sigma)) that yields stable, low-jitter resonances.

## High-level idea (PIT terms)

* **Φ (state)**: instantaneous orbital state (positions/velocities; mean longitudes, periapses…).
* **K (kernel)**: a scalar coherence mode (C) representing “how locked-in” the chain currently is.
* **Interface (F[Φ])**: resonance-detuning window (W_{ij}) per adjacent pair ((i,j)), e.g. Gaussian in normalized detuning from a target p:q MMR.
* **Energy/force**: a PIT Hamiltonian term (-\kappa,W_{ij}\cos\phi_{ij}) per pair; its gradient adds **small tangential kicks** that reduce detuning when coherence is high.

## Module layout

```
projects/loom-hd110067/
  README.md                <-- you are here
  SPEC.md                  <-- Loom spec v0.4 (contract + equations)
  pit_physics.jl           <-- PIT interaction layer (to be (re)implemented by Codex)
  main.jl                  <-- entry point: init system, integrate, log, plot
  data/
    hd110067_posteriors.json  <-- (optional) TTV posterior draws for masses/ecc
  scripts/
    run_sweep.sh           <-- convenience sweep launcher
    plot_notebook.jl       <-- quick plotting helpers (Makie/Plots)
  tests/
    runtests.jl            <-- unit & property tests
  config/
    default.toml           <-- parameters & toggles
```

## Quick start (intended)

```bash
# 1) Instantiate environment (Project.toml will be generated by Codex)
julia --project -e 'using Pkg; Pkg.instantiate()'

# 2) Run baseline with PIT ON
julia --project main.jl --config config/default.toml --steps 200000 --dt 0.001

# 3) Run falsification (PIT OFF: xi=0)
julia --project main.jl --config config/default.toml --override "K.xi=0.0" --steps 200000 --dt 0.001

# 4) Parameter sweep
bash scripts/run_sweep.sh
```

## Outputs

* `out/trajectory.parquet` – time series of periods, resonant angles, (C(t)), window means, etc.
* `out/metrics.json` – summary metrics: libration amplitudes, capture fractions, recovery times, jitter.
* `out/figs/*.png` – resonant-angle and period-ratio plots; phase portraits; sweep heatmaps.

## Dependencies (suggested)

* `DifferentialEquations.jl` (symplectic/explicit integrators) **or** a simple kick-drift-kick leapfrog we serialize locally.
* `StaticArrays.jl`, `LinearAlgebra`, `Distributions.jl`, `JSON3.jl`, `TOML.jl`, `Parsers.jl`, `DataFrames.jl`, `Arrow.jl` or `Parquet2.jl`, `Plots.jl`/`CairoMakie.jl`.
